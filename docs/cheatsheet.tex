\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage[spanish]{babel}
\begin{document}
\section*{Cobra Cheatsheet}
\begin{tabular}{ll}
\textbf{Comando} & \textbf{Descripción}\\\hline
func & Definición de función\\
clase & Definición de clase\\
metodo & Declaración de método\\
atributo & Acceso a atributo\\
si & Condicional\\
para & Bucle para\\
mientras & Bucle mientras\\
romper & Salir de bucle\\
continuar & Continuar bucle\\
regresar & Valor de retorno\\
importar & Importación de módulo\\
intentar & Bloque de manejo de errores\\
excepto & Captura de excepción\\
\end{tabular}

\section*{Colecciones}
\begin{tabular}{ll}
\textbf{Función} & \textbf{Descripción}\\\hline
\texttt{mapear(lista, funcion)} & Aplica una función preservando el orden.\\
\texttt{filtrar(lista, funcion)} & Conserva los elementos que cumplan la condición.\\
\texttt{reducir(lista, funcion, inicial)} & Acumula valores de izquierda a derecha.\\
\texttt{encontrar(lista, funcion)} & Devuelve el primer elemento válido o \texttt{None}.\\
\texttt{aplanar(lista)} & Colapsa un nivel de anidación en una nueva lista.\\
\texttt{agrupar\_por(lista, clave)} & Agrupa por clave manteniendo el orden de llegada.\\
\texttt{particionar(lista, funcion)} & Divide en dos listas (verdaderos y falsos).\\
\texttt{mezclar(lista, semilla)} & Copia barajada con semilla opcional para pruebas.\\
\texttt{zip\_listas(a, b, ...)} & Crea tuplas alineadas hasta la lista más corta.\\
\texttt{tomar(lista, n)} & Obtiene los primeros \texttt{n} elementos sin mutar.\\
\texttt{tomar\_mientras(lista, funcion)} & Prefijo mientras la condición sea cierta; inspirado en Kotlin \texttt{takeWhile} y Ruby \texttt{Enumerable\#take\_while}.\\
\texttt{descartar\_mientras(lista, funcion)} & Omite el prefijo que cumple la condición, como \texttt{dropWhile} de Kotlin y Ruby \texttt{Enumerable\#drop\_while}.\\
\texttt{scanear(lista, funcion, inicial)} & Acumulaciones parciales al estilo Kotlin \texttt{scan}/\texttt{runningFold} y Ruby \texttt{Enumerable\#inject}.\\
\texttt{pares\_consecutivos(lista)} & Pares deslizantes, similar a Kotlin \texttt{zipWithNext} y Ruby \texttt{each\_cons(2)}.\\
\texttt{mapear\_seguro(lista, funcion)} & Devuelve resultados y excepciones por elemento.\\
\texttt{ventanas(lista, tam, paso)} & Genera ventanas deslizantes; usa \texttt{incluir\_incompletas}.\\
\texttt{chunk(lista, tam)} & Construye bloques consecutivos del mismo tamaño.\\
\end{tabular}

\section*{Lógica}
\begin{tabular}{ll}
\textbf{Función} & \textbf{Descripción}\\\hline
\texttt{conjuncion(a, b)} & Verdadero solo si ambos argumentos lo son.\\
\texttt{disyuncion(a, b)} & Verdadero si al menos un argumento lo es.\\
\texttt{negacion(valor)} & Invierte el valor lógico.\\
\texttt{xor(a, b)} & Verdadero cuando los argumentos difieren.\\
\texttt{nand(a, b)} & Equivale a \texttt{not (a and b)}.\\
\texttt{nor(a, b)} & Equivale a \texttt{not (a or b)}.\\
\texttt{implica(a, b)} & Falsa solo cuando \texttt{a} es verdadero y \texttt{b} falso.\\
\texttt{equivale(a, b)} & Verdadera cuando ambos valores coinciden.\\
\texttt{xor\_multiple(*valores)} & XOR acumulado; requiere al menos dos entradas.\\
\texttt{todas(valores)} & Valida que todos los elementos sean verdaderos.\\
\texttt{alguna(valores)} & Comprueba si al menos un elemento es verdadero.\\
\end{tabular}

\textit{Todas las funciones validan que las entradas sean booleanas y lanzan \texttt{TypeError} si se proporciona otro tipo.}

\section*{Números}
\begin{tabular}{ll}
\textbf{Función} & \textbf{Descripción}\\\hline
\texttt{mcd(a, b, ...)} & Máximo común divisor como \texttt{math.gcd}.\\
\texttt{mcm(a, b, ...)} & Mínimo común múltiplo equivalente a \texttt{math.lcm}.\\
\texttt{es\_cercano(a, b, tol\_rel, tol\_abs)} & Compara con tolerancias opcionales.\\
\texttt{producto(valores, inicio)} & Multiplica todo el iterable partiendo de ``inicio``.\\
\texttt{entero\_a\_base(n, base, alfabeto)} & Convierte enteros a bases 2--36 con alfabeto opcional.\\
\texttt{entero\_desde\_base(texto, base, alfabeto)} & Reconstruye enteros validando el alfabeto.\\
\end{tabular}

\textit{Las conversiones de base admiten signos negativos y rechazan bases fuera del intervalo [2, 36].}

\section*{Texto}
\begin{tabular}{ll}
\textbf{Función} & \textbf{Descripción}\\\hline
\texttt{quitar\_prefijo(cad, prefijo)} & Elimina el prefijo si existe, como \texttt{str.removeprefix}.\\
\texttt{quitar\_sufijo(cad, sufijo)} & Recorta el sufijo coincidente, inspirado en \texttt{str.removesuffix}.\\
\texttt{dividir\_lineas(cad, conservar)} & Divide por saltos de línea opcionalmente manteniéndolos.\\
\texttt{expandir\_tabulaciones(cad, ancho)} & Reemplaza tabuladores por espacios como \texttt{str.expandtabs}.\\
\texttt{subcadena\_antes(cad, sep, defecto)} & Prefijo antes del primer separador; como Kotlin \texttt{substringBefore}.\\
\texttt{subcadena\_despues(cad, sep, defecto)} & Sufijo tras el primer separador; equivalente a \texttt{substringAfter}.\\
\texttt{subcadena\_antes\_ultima(cad, sep, defecto)} & Prefijo previo a la última coincidencia; similar a \texttt{substringBeforeLast}.\\
\texttt{subcadena\_despues\_ultima(cad, sep, defecto)} & Segmento posterior a la última coincidencia; como \texttt{substringAfterLast}.\\
\texttt{contar\_subcadena(cad, sub, ini, fin)} & Cuenta apariciones sin solapamiento en el intervalo dado.\\
\texttt{centrar\_texto(cad, ancho, relleno)} & Centra la cadena rellenando con un carácter.\\
\texttt{rellenar\_ceros(cad, ancho)} & Antepone ceros respetando signos como \texttt{str.zfill}.\\
\texttt{minusculas\_casefold(cad)} & Convierte a minúsculas Unicode agresivas (casefold).\\
\texttt{intercambiar\_mayusculas(cad)} & Invierte mayúsculas/minúsculas como \texttt{str.swapcase}.\\
\texttt{es\_titulo(cad)} & Comprueba formato título sensible a acentos vía \texttt{str.istitle}.\\
\texttt{es\_digito(cad)} & Verifica dígitos Unicode mediante \texttt{str.isdigit}.\\
\end{tabular}

\section*{Datos tabulares}
\begin{tabular}{ll}
\textbf{Función} & \textbf{Descripción}\\\hline
\texttt{ordenar\_tabla(datos, por, ascendente)} & Ordena múltiples columnas al estilo pandas/R manteniendo listas de registros.\\
\texttt{combinar\_tablas(izq, der, claves, tipo)} & Realiza joins internos/externos validando claves antes de cruzar la información.\\
\texttt{rellenar\_nulos(datos, valores)} & Sustituye valores perdidos por columna siguiendo reglas declarativas.\\
\texttt{pivotar\_tabla(datos, index, columnas, valores, agregacion)} & Reorganiza métricas a formato ancho con agregaciones múltiples.\\
\end{tabular}
\end{document}
